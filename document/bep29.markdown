# [utp传输协议](http://www.bittorrent.org/beps/bep_0029.html)

由Ludvig Strigeus、Greg Hazel、Stanislav Shalunov、Arvid Norberg和Bram Cohen设计。

## 理论基础

uTP的动机是BitTorrent客户端不能消耗全部带宽，同时仍然充分利用未使用的带宽。

问题是DSL和光纤调制解调器通常有一个与其最大发送速率不成比例的发送缓冲区，它可以容纳几秒钟的数据包。BitTorrent流量通常在后台传输，其优先级应低于电子邮件、电话和浏览网页等，但当使用常规TCP连接时，BitTorrent会迅速填满发送缓冲区，从而为所有交互流量增加数秒的延迟。

BitTorrent使用多个TCP连接的事实使其在与其他服务争夺带宽时具有不公平的优势，这夸大了BitTorrent上传的效果。这是因为TCP将可用带宽均匀地分布在各个连接上，并且一个应用程序使用的连接越多，它获得的带宽份额就越大。

传统的解决方案是将BitTorrent客户端的上传速率限制为上行链路容量的80%。这为用户留出了空间。

此解决方案的主要缺点是：

- 用户需要配置BitTorrent客户端，不能开箱即用~~就是懒~~。

- 用户需要知道其internet连接的上行带宽。这种带宽可能会改变，特别是在可能连接到大量不同网络的笔记本电脑上。

- 20%的冗余太随便了，浪费了带宽。每当没有交互流量与BitTorrent竞争时，额外的20%就被浪费了。每当有相互竞争的交互流量时，它不能使用超过20%的容量。

uTP通过使用调制解调器队列大小作为发送速率的控制器来解决这个问题。当队列增长过大时，它会进行节流。

这使得它可以在没有竞争对手的情况下充分利用上传带宽，并且在有大量交互流量的情况下，它可以将流量限制为几乎为零。

## 概述

本文假设您了解TCP和基于窗口期的流量控制的工作原理。

UTP是一种在UDP之上分层的传输协议。因此，它必须（并且有能力）实施自己的流量控制。

与TCP的主要区别在于基于时延的流量控制。请参阅流量控制部分。

与TCP一样，uTP使用基于窗口的流量控制。每个套接字都有一个max_window，用于确定套接字在任何给定时间内可能具有的最大字节数。任何已发送但尚未确认的数据包都被视为正在传输中。

当前窗口中正在传输的包是cur_window

如果cur_window+packet_size小于或等于min（max_window，wnd_size），则套接字只能发送一个数据包。数据包大小可能不同，请参阅数据包大小部分。

wnd_size是另一端的窗口。它对传输中的数据包数设置了一个上限。

如果max_window小于数据包大小，则实现可能违反上述规则，并对数据包进行调整，使平均cur_window小于或等于max_window。

每个套接字保持另一个端点（reply_micro）最后一次延迟测量的状态。每当接收到一个数据包时，就会通过从主机当前时间中减去timestamp_microseconds（以微秒为单位的对面的时间戳）来更新此状态（请参阅报头格式）。

每次发送数据包时，sockets reply_micro值都会放入数据包头的timestamp_difference_microseconds字段中。

与TCP不同，uTP中的序列号和ack指的是数据包，而不是字节。这意味着uTP在重新发送数据时无法重新打包数据。

每个套接字保留发送数据包时要使用的下一个序列号的状态seq_nr。它还保留上次接收的序列号的状态ack_nr。最早的未确认数据包是seq_nr-cur_window。

## 报头格式

版本1 头部:

单位 bit

```
0       4       8               16              24              32
+-------+-------+---------------+---------------+---------------+
| type  | ver   | extension     | connection_id                 |
+-------+-------+---------------+---------------+---------------+
| timestamp_microseconds                                        |
+---------------+---------------+---------------+---------------+
| timestamp_difference_microseconds                             |
+---------------+---------------+---------------+---------------+
| wnd_size                                                      |
+---------------+---------------+---------------+---------------+
| seq_nr                        | ack_nr                        |
+---------------+---------------+---------------+---------------+
```

全部字段都是大端序

- version

协议版本 当前是1

- connection_id

是一个随机的 独一无二的数字，用来标识属于同一次连接的数据包。 每个socket都有一个connection_id 来发送，还有另一个connection_id来接受。 终点(endpoint)
初始化连接，决定用什么id，然后返回id+1的路径

- timestamp_microseconds

这是发送此数据包时的时间戳的“微秒”部分。 posix上使用gettimeofday，windows上是QueryPerformanceTimer（）。 这个时间戳的分辨率越高越好。设定的传输时间越接近实际传输时间（越近）越好。

- timestamp_difference_microseconds

这是在接收最后一个报文时，在最后一个接收报文中的时间戳和本机时间之间的差异。 这是从远程peer到本地计算机的链路的最新单向延迟。 当新打开的套接字没有任何延迟样本时，必须将其设置为0。

- wnd_size

广播接收窗口。32位宽，以字节为单位指定。 窗口大小是当前正在传输的字节数，即已发送但未确认。 如果接收缓冲区已满，则广播接收窗口允许另一端在接收速度无法加快时限制窗口大小。 发送数据包时，应将其设置为套接字接收缓冲区中剩余的字节数。

- extension

扩展头部(extension header)链表中第一个extension的类型。0表示没有扩展(空的)。

当前有一个扩展

1. Selective acks

扩展是连起来的，就像TCP option一样。如果扩展字段不为零，则紧跟在UTP报头之后的是两个字节：

```
0               8               16
+---------------+---------------+
| extension     | len           |
+---------------+---------------+
```

其中extension指定链表中下一个扩展名类型，0终止该链表。 len指定此扩展的字节数。只需跳过len字节就可以跳过未知扩展。一个extension后紧跟另一个

SELECTIVE ACK （选择性确认）

SELECTIVE ACK是一种扩展，它可以选择性地确认没有顺序的报文。 它的有效载荷是至少32位的位掩码(bitmask)，以32的倍数表示。每一位表示发送窗口中的一个数据包。超出发送窗口的位将被忽略。
一个被置为1的位表示该数据包已被接收，一个被置为0的位表示该数据包尚未被接收。扩展头部如下所示：

```
0               8               16
+---------------+---------------+---------------+---------------+
| extension     | len           | bitmask
+---------------+---------------+---------------+---------------+
                                |
+---------------+---------------+
```

注意，扩展的len字段指的是字节，在此扩展中，len必须至少为4，并且是4的倍数。

只有在接收到的流中跳过至少一个序列号时，才发送SELECTIVE ACK。 因此，掩码中的第一位表示ack_nr+2。在发送此数据包时，假定ack_nr+1已被丢弃或丢失。
一个被置为1的位表示已接收的数据包，一个被置为0的位表示尚未接收的数据包。

位掩码的字节序相反。第一个字节以相反的顺序表示数据包[ack_nr+2，ack_nr+2+7]。 字节中的最低有效位表示ack_nr+2，字节中的最高有效位表示ack_nr+2+7。
掩码中的下一个字节按相反顺序表示[ack_nr+2+8，ack_nr+2+15]，依此类推。 位掩码不限于32位，但可以是任何大小。

这里有个表示在SELECTIVE ACK的位字段（bitfield）中表示的前32个报文ACK的位掩码的布局：

```
0               8               16
+---------------+---------------+---------------+---------------+
| 9 8 ...   3 2 | 17   ...   10 | 25   ...   18 | 33   ...   26 |
+---------------+---------------+---------------+---------------+
```

图中的数字将位掩码中的位映射到要添加到ack_nr的偏移量，以便计算位正在ACK的序列号。

type

type字段描述了报文的类型

它可以是其中之一：

ST_DATA = 0

常规数据包。套接字处于连接状态，并且有数据要发送。ST_DATA 数据包总是有一个数据负载。

ST_FIN = 1

完成连接。这是最后一个报文了。它关闭连接，类似于TCP FIN flag。 此连接的序列号永远不会大于此数据包中的序列号。套接字将此序列号记录为 eof_pkt。 这使得套接字可以等待可能仍然丢失的数据包，甚至在接收到 ST_FIN
数据包之后，这些数据包也会无序到达。

ST_STATE = 2

状态数据包。用于传输无数据的ACK。不包含任何有效负载的数据包，也不会增加 seq_nr（序列号）。

ST_RESET = 3

强行终止连接。类似于TCP RST标志。远程主机没有此连接的任何状态。它已过时，应该终止。

ST_SYN = 4

连接SYN。与TCP SYN flag类似，这个包启动一个连接。序列号初始化为1。 连接ID初始化为随机数。SYN数据包是特殊的，在这个连接上发送的所有后续数据包（除了ST_SYN的重新发送）都是用connection id+1发送的。
connection ID是另一端在其响应中应该使用的。

当接收到STU_SYN时，新的套接字应该用报头中的ID初始化。套接字的发送ID应初始化为ID+1。返回通道的序列号初始化为随机数。另一端需要一个 ST_STATE 包（只有一个ACK）作为响应。

seq_nr

这是这个包的序列号。与TCP相反，uTP序列号不是指字节，而是指数据包。序列号告诉另一端，数据包应该以何种顺序返回到应用层。

ack_nr

数据包的发送方最后一次收到对面的数据包的序列号。

## 建立连接

下面是一个示意图，说明了用于启动连接交换的报文和状态。c.* 表示套接字本身的状态，pkt.* 表示数据报头中的字段。

```
initiating endpoint                           accepting endpoint

          | c.state = CS_SYN_SENT                         |
          | c.seq_nr = 1                                  |
          | c.conn_id_recv = rand()                       |
          | c.conn_id_send = c.conn_id_recv + 1           |
          |                                               |
          |                                               |
          | ST_SYN                                        |
          |   seq_nr=c.seq_nr++                           |
          |   ack_nr=*                                    |
          |   conn_id=c.rcv_conn_id                       |
          | >-------------------------------------------> |
          |             c.receive_conn_id = pkt.conn_id+1 |
          |             c.send_conn_id = pkt.conn_id      |
          |             c.seq_nr = rand()                 |
          |             c.ack_nr = pkt.seq_nr             |
          |             c.state = CS_SYN_RECV             |
          |                                               |
          |                                               |
          |                                               |
          |                                               |
          |                     ST_STATE                  |
          |                       seq_nr=c.seq_nr++       |
          |                       ack_nr=c.ack_nr         |
          |                       conn_id=c.send_conn_id  |
          | <------------------------------------------<  |
          | c.state = CS_CONNECTED                        |
          | c.ack_nr = pkt.seq_nr                         |
          |                                               |
          |                                               |
          |                                               |
          | ST_DATA                                       |
          |   seq_nr=c.seq_nr++                           |
          |   ack_nr=c.ack_nr                             |
          |   conn_id=c.conn_id_send                      |
          | >-------------------------------------------> |
          |                        c.ack_nr = pkt.seq_nr  |
          |                        c.state = CS_CONNECTED |
          |                                               |
          |                                               | connection established
     .. ..|.. .. .. .. .. .. .. .. .. .. .. .. .. .. .. ..|.. ..
          |                                               |
          |                     ST_DATA                   |
          |                       seq_nr=c.seq_nr++       |
          |                       ack_nr=c.ack_nr         |
          |                       conn_id=c.send_conn_id  |
          | <------------------------------------------<  |
          | c.ack_nr = pkt.seq_nr                         |
          |                                               |
          |                                               |
          V                                               V g
```

连接由它们的conn_id头标识。 如果新连接的connection ID与现有连接冲突，则连接尝试将失败，因为现有流中不需要ST_SYN数据包，并且它将被忽略。

## 丢包

如果序列号为（seq_nr-cur_window）的数据包没有得到确认（这是发送缓冲区中最旧的数据包，下一个数据包预计会得到确认）， 但是有3个或更多的比他先发送的数据包经过了确认（通过选择性确认），则假定数据包已经丢失。
类似地，当接收到3个重复ack时，假设ack_nr+1已丢失（如果已发送具有该序列号的报文）。

这也适用于selective acks。在选择性ack消息中被ack的每个包都算作一个重复ack， 如果它有3个或更多个，则应该触发在它们之后至少有3个包被ack的包的重新发送。

当数据包丢失时，max_window 被乘以0.5，以模拟TCP。

## 超时

每个被确认的数据包，不论是落在范围内[last_ack_nr，ack_nr]内或通过选择性ack消息显式地确认的每个数据包，都应用于更新rtt（往返时间）和rtt_var（rtt方差）度量。
last_ack_nr这里是当前数据包之前在这个套接字上接收的最后一个ack_nr，ack_nr是当前接收数据包中的字段

rtt和rtt_var只针对只发送一次的数据包进行更新。这样就避免了找出哪个才是被确认的数据包的问题。

每次确认数据包时，通过以下公式计算rtt和rtt_var：

```
delta = rtt - packet_rtt
rtt_var += (abs(delta) - rtt_var) / 4;
rtt += (packet_rtt - rtt) / 8;
```

每次更新rtt和rtt_var时，也会更新与套接字关联的数据包的默认超时。设置为：

```
timeout = max(rtt + rtt_var * 4, 500);  #ms
```
其中以毫秒为单位指定超时。i.e 数据包的最小超时时间是1/2秒。

每次套接字发送或接收数据包时，它都会更新其超时计数器。如果在上次超时计数器重置后的超时毫秒数内没有数据包到达，套接字将触发超时。
它将其数据包大小和最大窗口设置为最小数据包大小（150字节）。这允许它再发送一个数据包，如果窗口大小降到零，套接字就是这样重新启动的。

初始超时设置为1000毫秒，然后根据上面的公式进行更新。对于超时的每个数据包，其超时时间将加倍。

## 报文尺寸

为了尽可能减少对缓慢拥塞网络的影响，uTP将其数据包大小调整为每个数据包150字节。使用这么小的数据包的好处是不会阻塞慢速链接，而且序列化延迟很长。
使用如此小的数据包的代价是来自数据包头的开销变得非常大。在高速率下，使用大数据包，在低速率下，使用小数据包。

## 拥塞控制

uTP拥塞控制的总体目标是使用单向缓冲区延迟作为主要的拥塞度量，以及像TCP一样的数据包丢失。
关键是要避免在发送数据时使用完整的发送缓冲区运行。对于DSL/电缆调制解调器来说，这是一个特别的问题，调制解调器中的发送缓冲区通常有空间容纳数秒的数据。
uTP（或任何后台通信协议）的理想缓冲区利用率是以0字节缓冲区利用率运行。i.e.任何其他通信都可以在任何时候发送，而不会被阻塞发送缓冲区的后台通信阻塞。
在实践中，uTP目标延迟被设置为100毫秒。每个套接字的目标是在发送链路上看不到超过100毫秒的延迟。如果它这样做了，它就会减速。

这有效地使uTP让步于任何TCP流量

这是通过在通过uTP发送的每个包中包含高分辨率时间戳来实现的，并且接收端计算其自身的高分辨率计时器和其接收的包中的时间戳之间的差。
然后将此差异反馈给数据包的原始发送方（timestamp_difference_microseconds）。此值作为绝对值没有意义。机器中的时钟很可能不同步，
特别是不到微秒的分辨率，数据包传输的时间也包括在这些时间戳的差异中。但是，与以前的值相比，该值很有用。

每个socket保存之前2min滑动最小值。这个值称为 base_delay，用作基线，即主机之间的最小延迟。
当从每个数据包的时间戳之差中减去base_delay时，就得到了套接字上当前缓冲延迟的测量值。这种测量称为我们的延迟（our_delay）。它有很多噪音，
但它被用作驱动程序来决定是增加还是减少发送窗口（控制发送速率）。

 CCONTROL_TARGET是uTP在上行链路上接受的缓冲延迟。当前延迟目标设置为100 ms。
off_target是实际测量的延迟距离目标延迟的距离（根据CCONTROL_TARGET - our_delay计算）。

socket结构中的窗口大小指定了我们在连接中的总字节数（未确认的那些）。发送速率与此窗口大小直接相关。正在传输（in flight）的字节越多，发送速度越快。
在代码中，窗口大小称为max_window。其大小大致由以下表达式控制：
```
delay_factor = off_target / CCONTROL_TARGET;
window_factor = outstanding_packet / max_window;
scaled_gain = MAX_CWND_INCREASE_PACKETS_PER_RTT * delay_factor * window_factor;
```
其中，第一个因子将 off_target 缩放为和目标延迟一样的单位。

然后将scaled_gain添加到max_window:
```
max_window += scaled_gain;
```

如果off_target大于0，这将使窗口变小；如果off_target小于0，则使窗口变大。

如果max_window变为小于0，则将其设置为0。窗口大小为零意味着套接字可能不会发送任何数据包。
在此状态下，套接字将触发超时并强制窗口大小为一个数据包大小，然后发送一个数据包。有关详细信息，请参阅超时部分。